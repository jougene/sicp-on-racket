###Упражнение 2.4.
Вот еще одно процедурное представление для пар. Проверьте для этого представления, что при 
любых двух объектах `x` и `y` `(car (cons x y))` возвращает `x`.
```racket
  (define (cons x y)
    (lambda (m) (m x y)))
```
```racket
  (define (car z)
    (z (lambda (p q) p)))
```    
Каково соответствующее определение `cdr?` (Подсказка: Чтобы проверить, что это работает, 
используйте подстановочную модель из раздела 1.1.5.)

###Описание решения

Вполне логично, что соответствующее определение для `cdr` будет:

```racket
  (define (cdr z)
    (z (lambda (p q) q)))
```
==
Чтобы проверить, что это работает, воспользуемся подстановочной моделью вычислений. `cons` возвращает процедуру от одного аргумента.

Подставим вместо `z` нашу люмбду - (λ (m) (m x y)), вместо `m` мы подставим ее аргумент, т.е. `(λ (p q) p)`

Получается: 
```racket 
  (λ (λ (p q) p)
    ((λ (p q) p) x y)
```
подставляем на место `p` и `q` наши `x` и `y`, получаем
```racket 
  (λ (λ (p q) p)
    ((λ (x y) x)))
```

Соответственно `(λ (λ (p q) p)`, т.е. `(car z)` возвращает `x`.
====
Аналогично для `(car z)`
```racket 
  (λ (λ (p q) p)
    ((λ (p q) p) x y)
```
```racket 
  (λ (λ (p q) p)
    ((λ (x y) y)))
```
Соответственно `(λ (λ (p q) p)`, т.е. `(cdr z)` возвращает `y`.

[Решение] (../../src/chapter02/ex-2-04.rkt)
